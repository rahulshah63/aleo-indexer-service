// aleo-indexer/src/core/processor.ts

import { logger } from '../utils/logger.js';
import { getNestedValue, ProgramConfig, FunctionConfig, MappingConfig, AleoValueType, AleoPrimitiveType, DbInstance, GeneratedSchema } from '../utils/types.js';
import { callRpc, AleoTransaction } from './rpc.js';

/**
 * Represents a request to update a specific mapping key's value,
 * originating from a processed function call.
 */
interface MappingUpdateCandidate {
  programId: string;
  mappingName: string;
  key: string; // The raw Aleo string representation of the key
  value?: string; // Optional: The raw Aleo string representation of the value, if directly available from function output/finalize
  blockHeight: number; // The block height at which this update was observed
}


const BATCH_SIZE = 50; // Number of transactions to fetch per RPC call

/**
 * Parses and transforms an Aleo transaction based on the function configuration.
 * @param tx The raw Aleo transaction object.
 * @param funcConfig The configuration for the function being processed.
 * @param programConfig The configuration for the entire Aleo program. // ADDED THIS PARAMETER
 * @returns An object containing data for the main transactions table, function-specific table,
 * and any mapping update candidates generated by this transaction.
 */
function parseTransactionAndCollectMappingUpdates(tx: AleoTransaction, funcConfig: FunctionConfig, programConfig: ProgramConfig) { // ADDED programConfig
  // Extract common fields for the main transactions table
  const baseTxData = {
    id: tx.transaction.id,
    programId: tx.transaction.execution?.transitions?.[0]?.program || 'unknown',
    functionName: tx.transaction.execution?.transitions?.[0]?.function || 'unknown',
    blockHeight: tx.finalizedAt ? parseInt(tx.finalizedAt.split('.')[0]) : 0,
    timestamp: tx.finalizedAt ? new Date(parseInt(tx.finalizedAt) * 1000) : new Date(),
    raw: tx, // Store the entire raw transaction for debugging/auditing
  };

  // Extract specific fields for the function's dedicated table
  const funcSpecificData: { [key: string]: any } = {};
  for (const input of funcConfig.inputs) {
    let inputValue: any;
    const transitionInputs = tx.transaction?.execution?.transitions?.[0]?.inputs;

    if (input.rpcPath) {
      inputValue = getNestedValue(tx, input.rpcPath);
    } else if (transitionInputs) {
      const foundInput = transitionInputs.find(i => i.id === input.name);
      inputValue = foundInput?.value;

      if (input.aleoType.kind === 'record' || input.aleoType.kind === 'struct' || input.aleoType.kind === 'array') {
        try {
          inputValue = JSON.parse(inputValue);
        } catch (e) {
          logger.warn({
            service: 'processor',
            msg: `Failed to parse complex input for ${input.name}: ${inputValue}`,
            error: e,
          });
        }
      } else if (input.aleoType.kind === 'primitive' && (input.aleoType.type === 'u64' || input.aleoType.type === 'u128')) {
        inputValue = BigInt(inputValue);
      }
    }
    funcSpecificData[input.name] = inputValue;
  }

  for (const dbColumnName in funcConfig.extract) {
    const rpcPath = funcConfig.extract[dbColumnName];
    funcSpecificData[dbColumnName] = getNestedValue(tx, rpcPath);
  }

  // Collect mapping update candidates
  const mappingUpdateCandidates: MappingUpdateCandidate[] = [];
  const blockHeight = baseTxData.blockHeight;

  if (funcConfig.triggersMappingUpdates) {
    for (const trigger of funcConfig.triggersMappingUpdates) {
      const key = getNestedValue(funcSpecificData, trigger.keySource);
      if (key !== undefined) { // Ensure key was successfully extracted
        const candidate: MappingUpdateCandidate = {
          programId: programConfig.programId, // Use programConfig from parameter
          mappingName: trigger.mappingName,
          key: String(key), // Ensure key is string for RPC calls
          blockHeight: blockHeight,
        };
        if (trigger.valueSource) {
            const value = getNestedValue(funcSpecificData, trigger.valueSource);
            if (value !== undefined) {
                candidate.value = String(value); // Ensure value is string
            }
        }
        mappingUpdateCandidates.push(candidate);
      } else {
        logger.warn({
          service: 'processor',
          msg: `Mapping update trigger for '${trigger.mappingName}' in function '${funcConfig.name}' could not extract key from source '${trigger.keySource}'.`,
          transactionId: tx.transaction.id,
        });
      }
    }
  }

  // Also collect updates from the transaction's `finalize` section, as they directly state mapping changes
  if (tx.finalize && tx.finalizedAt) {
      for (const finalizeEntry of tx.finalize) {
          // Find which configured mapping this finalize entry corresponds to
          const matchingMappingConfig = programConfig.mappings?.find( // programConfig is now in scope
              m => m.name === finalizeEntry.mapping_id.split('/').pop() // Extract mapping name from mapping_id
          );

          if (matchingMappingConfig) {
              const key = getNestedValue(finalizeEntry, matchingMappingConfig.key.rpcPath || 'key_id');
              const value = getNestedValue(finalizeEntry, matchingMappingConfig.rpcValuePath || 'value_id');

              if (key !== undefined && value !== undefined) {
                  mappingUpdateCandidates.push({
                      programId: programConfig.programId, // Use programConfig from parameter
                      mappingName: matchingMappingConfig.name,
                      key: String(key),
                      value: String(value),
                      blockHeight: blockHeight,
                  });
              } else {
                  logger.warn({
                      service: 'processor',
                      msg: `Finalize entry for mapping '${matchingMappingConfig.name}' could not extract key or value.`,
                      transactionId: tx.transaction.id,
                  });
              }
          }
      }
  }


  return {
    baseTxData,
    funcSpecificData,
    mappingUpdateCandidates,
  };
}

/**
 * Handles the indexing of functions defined in a program configuration.
 * Fetches transactions, parses them, and inserts into the appropriate tables.
 * @param programConfig The configuration for the current Aleo program.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 * @param currentPage The page number to start fetching transactions from.
 * @returns An object containing the next page number and a list of generated mapping update candidates.
 */
export async function handleProgramFunctions(
  programConfig: ProgramConfig,
  rpcUrl: string,
  db: DbInstance,
  schema: GeneratedSchema,
  currentPage: number
): Promise<{ nextPage: number; mappingUpdateCandidates: MappingUpdateCandidate[] }> {
  if (!programConfig.functions || programConfig.functions.length === 0) {
    return { nextPage: currentPage, mappingUpdateCandidates: [] }; // No functions to process
  }

  logger.info({
    service: 'processor',
    msg: `Processing functions for program '${programConfig.programId}' starting from page ${currentPage}`,
  });

  let hasMoreTransactions = true;
  let pageToProcess = currentPage;
  const allMappingUpdateCandidates: MappingUpdateCandidate[] = [];

  while (hasMoreTransactions) {
    let transactionsBatch: AleoTransaction[] = [];
    try {
      const response = await callRpc<AleoTransaction[]>(
        rpcUrl,
        "aleoTransactionsForProgram",
        {
          programName: programConfig.programId,
          page: pageToProcess,
          maxTransactions: BATCH_SIZE,
        }
      );
      transactionsBatch = (response || []).filter(tx => tx.status === "finalized" && tx.transaction?.execution?.transitions?.[0]?.program === programConfig.programId);

    } catch (e: any) {
      if (e.message.includes('RPC permanent error')) {
        logger.error({
          service: 'processor',
          msg: `Permanent RPC error fetching transactions for ${programConfig.programId} on page ${pageToProcess}: ${e.message}`,
        });
        hasMoreTransactions = false;
        break;
      }
      logger.warn({
        service: 'processor',
        msg: `Transient error fetching transactions for ${programConfig.programId} on page ${pageToProcess}: ${e.message}`,
        error: e.message,
      });
      // In case of transient error, return current candidates and page to retry
      return { nextPage: pageToProcess, mappingUpdateCandidates: allMappingUpdateCandidates };
    }

    if (transactionsBatch.length === 0) {
      logger.info({
        service: 'processor',
        msg: `No new finalized transactions for ${programConfig.programId} on page ${pageToProcess}.`,
      });
      hasMoreTransactions = false;
      break;
    }

    const baseTransactionsToInsert: any[] = [];
    const functionSpecificInserts: { [tableName: string]: any[] } = {};

    for (const tx of transactionsBatch) {
      const functionName = tx.transaction?.execution?.transitions?.[0]?.function;
      const funcConfig = programConfig.functions.find(f => f.name === functionName);

      if (funcConfig) {
        // PASSED programConfig HERE
        const { baseTxData, funcSpecificData, mappingUpdateCandidates } = parseTransactionAndCollectMappingUpdates(tx, funcConfig, programConfig);
        baseTransactionsToInsert.push(baseTxData);

        if (!functionSpecificInserts[funcConfig.tableName]) {
          functionSpecificInserts[funcConfig.tableName] = [];
        }
        functionSpecificInserts[funcConfig.tableName].push({
          transactionId: tx.transaction.id,
          ...funcSpecificData,
        });

        allMappingUpdateCandidates.push(...mappingUpdateCandidates); // Collect candidates
      } else {
        logger.warn({
          service: 'processor',
          msg: `Encountered unconfigured function '${functionName}' in program '${programConfig.programId}'. Skipping.`,
          transactionId: tx.transaction.id,
        });
      }
    }

    if (baseTransactionsToInsert.length > 0) {
      await db.insert(schema.transactions)
        .values(baseTransactionsToInsert)
        .onConflictDoNothing({ target: schema.transactions.id });
      logger.info({
        service: 'processor',
        msg: `Inserted ${baseTransactionsToInsert.length} base transactions for ${programConfig.programId}.`,
      });
    }

    for (const tableName in functionSpecificInserts) {
      const records = functionSpecificInserts[tableName];
      if (records.length > 0) {
        const targetTable = schema[tableName];
        if (targetTable) {
          await db.insert(targetTable)
            .values(records)
            .onConflictDoNothing();
          logger.info({
            service: 'processor',
            msg: `Inserted ${records.length} records into '${tableName}' for ${programConfig.programId}.`,
          });
        } else {
          logger.error({
            service: 'processor',
            msg: `Generated table '${tableName}' not found in schema. Skipping inserts.`,
          });
        }
      }
    }
    pageToProcess++;
  }
  return { nextPage: pageToProcess, mappingUpdateCandidates: allMappingUpdateCandidates };
}


/**
 * Handles the indexing of mappings defined in a program configuration.
 * Fetches mapping values from RPC and updates the corresponding tables,
 * primarily driven by candidates generated from function processing.
 * @param mappingUpdateCandidates A list of mapping update requests generated from function processing.
 * @param programConfigs All program configurations to find mapping definitions.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 */
export async function handleProgramMappings(
  mappingUpdateCandidates: MappingUpdateCandidate[],
  programConfigs: ProgramConfig[], // Needs all program configs to find mapping definitions
  rpcUrl: string,
  db: DbInstance,
  schema: GeneratedSchema
) {
  if (mappingUpdateCandidates.length === 0) {
    logger.info({ service: 'processor', msg: 'No mapping update candidates to process.' });
    return;
  }

  logger.info({
    service: 'processor',
    msg: `Processing ${mappingUpdateCandidates.length} mapping update candidates.`,
  });

  // Use a Set to store unique key-mapping pairs to avoid redundant RPC calls and DB updates
  // Format: `${programId}:${mappingName}:${key}`
  const uniqueUpdatesToProcess = new Set<string>();
  mappingUpdateCandidates.forEach(candidate => {
    uniqueUpdatesToProcess.add(`${candidate.programId}:${candidate.mappingName}:${candidate.key}`);
  });

  for (const uniqueKey of uniqueUpdatesToProcess) {
    const [programId, mappingName, keyString] = uniqueKey.split(':');

    // Find the relevant mapping configuration
    const programConfig = programConfigs.find(p => p.programId === programId);
    const mappingConfig = programConfig?.mappings?.find(m => m.name === mappingName);

    if (!mappingConfig) {
      logger.warn({
        service: 'processor',
        msg: `Mapping configuration not found for '${mappingName}' in program '${programId}'. Skipping update.`,
      });
      continue;
    }

    const targetTable = schema[mappingConfig.tableName];
    if (!targetTable) {
      logger.error({
        service: 'processor',
        msg: `Generated table '${mappingConfig.tableName}' not found in schema for mapping '${mappingName}'. Skipping update.`,
      });
      continue;
    }

    try {
        // Find the original candidate to get the block height and potentially a pre-parsed value
        const originalCandidate = mappingUpdateCandidates.find(
            c => c.programId === programId && c.mappingName === mappingName && c.key === keyString
        );
        const blockHeight = originalCandidate?.blockHeight || 0; // Use candidate's block height or fallback

        let rpcValue: string | undefined = originalCandidate?.value; // Use pre-extracted value if available

        if (rpcValue === undefined) { // If value wasn't directly provided by the function processing/finalize, fetch it via RPC
            rpcValue = await callRpc<string>(
                rpcUrl,
                "getMappingValue",
                {
                    programId: programId,
                    mappingName: mappingConfig.name,
                    key: keyString,
                }
            );
        }

        if (rpcValue !== undefined && rpcValue !== null) {
            const key = parseAleoValue(keyString, mappingConfig.key.aleoType);
            const value = parseAleoValue(rpcValue, mappingConfig.value);

            await db.insert(targetTable)
                .values({
                    key: key,
                    value: value,
                    lastUpdatedBlock: blockHeight, // Use candidate's block height
                })
                .onConflictDoUpdate({
                    target: targetTable.key,
                    set: {
                        value: value,
                        lastUpdatedBlock: blockHeight,
                    },
                });
            logger.debug({
                service: 'processor',
                msg: `Updated mapping '${mappingConfig.name}' with key '${keyString}' in block ${blockHeight}.`,
            });
        } else {
            logger.debug({
                service: 'processor',
                msg: `Mapping '${mappingConfig.name}' for key '${keyString}' returned no value from RPC. It might have been deleted or not exist.`,
            });
        }
    } catch (error: any) {
        logger.warn({
            service: 'processor',
            msg: `Failed to fetch or update mapping '${mappingConfig.name}' for key '${keyString}': ${error.message}`,
            error: error.message,
        });
    }
  }
}

/**
 * Helper to parse Aleo values (from RPC strings) into appropriate JS types.
 * @param aleoValueStr The string value from Aleo RPC (e.g., "123u128", "aleo123...", "{a: 1u8}").
 * @param targetType The expected Aleo type.
 * @returns The parsed JavaScript value.
 */
function parseAleoValue(aleoValueStr: string, targetType: AleoValueType): any {
  if (targetType.kind === 'primitive') {
    switch (targetType.type) {
      case 'address':
      case 'field':
      case 'boolean':
        return aleoValueStr;
      case 'u8':
      case 'u16':
      case 'u32':
        return parseInt(aleoValueStr.replace(/u(8|16|32)/, ''));
      case 'u64':
      case 'u128':
        return BigInt(aleoValueStr.replace(/u(64|128)/, ''));
      default:
        return aleoValueStr;
    }
  } else if (targetType.kind === 'record' || targetType.kind === 'struct' || targetType.kind === 'array') {
    try {
      return JSON.parse(aleoValueStr);
    } catch (e) {
      logger.warn({
        service: 'processor',
        msg: `Failed to parse complex Aleo value string as JSON for type ${targetType.kind}: ${aleoValueStr}`,
        error: e,
      });
      return aleoValueStr;
    }
  }
  return aleoValueStr;
}