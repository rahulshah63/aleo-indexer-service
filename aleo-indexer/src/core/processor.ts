// aleo-indexer/src/core/processor.ts

import { logger } from '../utils/logger.js';
import { getNestedValue, ProgramConfig, FunctionConfig, MappingConfig, AleoValueType, AleoPrimitiveType, DbInstance, GeneratedSchema, parseJSONLikeString, parseLeoTypedJSON } from '../utils/types.js';
import { callRpc, AleoTransaction } from './rpc.js';

/**
 * Represents a request to update a specific mapping key's value,
 * originating from a processed function call.
 */
interface MappingUpdateCandidate {
  programId: string;
  mappingName: string;
  key: string; // The raw Aleo string representation of the key
  value?: string; // Optional: The raw Aleo string representation of the value, if directly available from function output/finalize
  blockHeight: number; // The block height at which this update was observed
}

const BATCH_SIZE = 1; // Number of transactions to fetch per RPC call
const MAX_PAGES_PER_FUNCTION_CYCLE = 1; // Limit pages fetched per function per cycle to avoid huge batches

/**
 * Parses and transforms an Aleo transaction based on the function configuration.
 * @param tx The raw Aleo transaction object.
 * @param funcConfig The configuration for the function being processed.
 * @param programConfig The configuration for the entire Aleo program.
 * @returns An object containing data for the main transactions table, function-specific table,
 * and any mapping update candidates generated by this transaction.
 */
function parseTransactionAndCollectMappingUpdates(tx: AleoTransaction, funcConfig: FunctionConfig, programConfig: ProgramConfig) {
  // Extract common fields for the main transactions table
  const baseTxData = {
    id: tx.transaction.id,
    programId: tx.transaction.execution?.transitions?.[0]?.program || 'unknown',
    functionName: tx.transaction.execution?.transitions?.[0]?.function || 'unknown',
    blockHeight: tx.finalizedAt ? parseInt(tx.finalizedAt) : 0,
    timestamp: tx.finalizedAt ? new Date(parseInt(tx.finalizedAt) * 1000) : new Date(),
    raw: tx, // Store the entire raw transaction for debugging/auditing
  };

  // Extract specific fields for the function's dedicated table
  const funcSpecificData: { [key: string]: any } = {};
  for (const input of funcConfig.inputs || []) {
    let inputValue: any;
    const transitionInputs = tx.transaction?.execution?.transitions?.[0]?.inputs;

    if (input.rpcPath) {
      inputValue = getNestedValue(tx, input.rpcPath);
    } else if (transitionInputs) {
      const foundInput = transitionInputs.find(i => i.id === input.name);
      inputValue = foundInput?.value;

      if (input.aleoType.kind === 'record' || input.aleoType.kind === 'struct' || input.aleoType.kind === 'array') {
        try {
          inputValue = JSON.parse(inputValue);
        } catch (e) {
          logger.warn({
            service: 'processor',
            msg: `Failed to parse complex input for ${input.name}: ${inputValue}`,
            error: e,
          });
        }
      } else if (input.aleoType.kind === 'primitive' && (input.aleoType.type === 'u64' || input.aleoType.type === 'u128')) {
        inputValue = BigInt(inputValue);
      }
    }
    funcSpecificData[input.name] = inputValue;
  }

  for (const output of funcConfig.outputs || []) {
    let outputValue: any;
    const transitionOutputs = tx.transaction?.execution?.transitions?.[0]?.outputs[0].value;
    if(!transitionOutputs) {
      logger.warn({
        service: 'processor',
        msg: `No outputs found for transaction ${tx.transaction.id} in function ${funcConfig.name}.`,
      });
      continue; // Skip this output if no outputs are available
    }
    const parsedData = parseJSONLikeString(transitionOutputs) as {arguments: Record<string, any>[]};

    if (output.parsedPath) {
      outputValue = getNestedValue(parsedData, output.parsedPath);
    } else if (transitionOutputs) {
      const foundInput = parsedData.arguments.find(i => i.id === output.name);
      outputValue = foundInput?.value;
    }
    try {
      outputValue = parseLeoTypedJSON(outputValue);
    } catch (e) {
      logger.warn({
        service: 'processor',
        msg: `Failed to parse complex input for ${output.name}: ${outputValue}`,
        error: e,
      });
    }
    funcSpecificData[output.name] = outputValue;
  }

  for (const dbColumnName in funcConfig.extract) {
    const rpcPath = funcConfig.extract[dbColumnName];
    funcSpecificData[dbColumnName] = getNestedValue(tx, rpcPath);
  }

  // Collect mapping update candidates
  const mappingUpdateCandidates: MappingUpdateCandidate[] = [];
  const blockHeight = baseTxData.blockHeight;

  if (funcConfig.triggersMappingUpdates) {
    for (const trigger of funcConfig.triggersMappingUpdates) {
      const key = getNestedValue(funcSpecificData, trigger.keySource);
      if (key !== undefined) { // Ensure key was successfully extracted
        const candidate: MappingUpdateCandidate = {
          programId: programConfig.programId,
          mappingName: trigger.mappingName,
          key: String(key), // Ensure key is string for RPC calls
          blockHeight: blockHeight,
        };
        if (trigger.valueSource) {
            const value = getNestedValue(funcSpecificData, trigger.valueSource);
            if (value !== undefined) {
                candidate.value = String(value); // Ensure value is string
            }
        }
        mappingUpdateCandidates.push(candidate);
      } else {
        logger.warn({
          service: 'processor',
          msg: `Mapping update trigger for '${trigger.mappingName}' in function '${funcConfig.name}' could not extract key from source '${trigger.keySource}'.`,
          transactionId: tx.transaction.id,
        });
      }
    }
  }

  // Also collect updates from the transaction's `finalize` section, as they directly state mapping changes
  if (tx.finalize && tx.finalizedAt) {
      for (const finalizeEntry of tx.finalize) {
          // Find which configured mapping this finalize entry corresponds to
          const matchingMappingConfig = programConfig.mappings?.find(
              m => m.name === finalizeEntry.mapping_id.split('/').pop() // Extract mapping name from mapping_id
          );

          if (matchingMappingConfig) {
              const key = getNestedValue(finalizeEntry, matchingMappingConfig.key.rpcPath || 'key_id');
              const value = getNestedValue(finalizeEntry, matchingMappingConfig.rpcValuePath || 'value_id');

              if (key !== undefined && value !== undefined) {
                  mappingUpdateCandidates.push({
                      programId: programConfig.programId,
                      mappingName: matchingMappingConfig.name,
                      key: String(key),
                      value: String(value),
                      blockHeight: blockHeight,
                  });
              } else {
                  logger.warn({
                      service: 'processor',
                      msg: `Finalize entry for mapping '${matchingMappingConfig.name}' could not extract key or value.`,
                      transactionId: tx.transaction.id,
                  });
              }
          }
      }
  }

  return {
    baseTxData,
    funcSpecificData,
    mappingUpdateCandidates,
  };
}

/**
 * Handles the indexing of functions defined in a program configuration.
 * Fetches transactions, parses them, and inserts into the appropriate tables.
 *
 * This function iterates through each configured function name for RPC calls
 * and collects all relevant transactions before processing them in batches.
 * It ensures sequential processing by sorting transactions and relies on Drizzle's
 * onConflictDoNothing for idempotency.
 *
 * @param programConfig The configuration for the current Aleo program.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 * @param currentPage The page number to start fetching transactions from (acts as a general progress marker).
 * @returns An object containing the next page number and a list of generated mapping update candidates.
 */
export async function handleProgramFunctions(
  programConfig: ProgramConfig,
  rpcUrl: string,
  db: DbInstance,
  schema: GeneratedSchema,
  currentPage: number
): Promise<{ nextPage: number; mappingUpdateCandidates: MappingUpdateCandidate[] }> {
  if (!programConfig.functions || programConfig.functions.length === 0) {
    return { nextPage: currentPage, mappingUpdateCandidates: [] }; // No functions to process
  }

  logger.info({
    service: 'processor',
    msg: `Processing functions for program '${programConfig.programId}' starting from overall page ${currentPage}`,
  });

  const allMappingUpdateCandidates: MappingUpdateCandidate[] = [];
  const processedTransactionsSet = new Set<string>(); // To track transactions already added to the batch
  
  // This will control the overall indexing loop for the program's functions.
  // We'll cycle through fetching pages for each function until no new transactions are found
  // across all functions in a given cycle.
  let continueProgramIndexing = true;
  let currentOverallPage = currentPage; // Tracks the general progress for the program

  // Stores the current page for each function, allowing more granular progress tracking
  // if the RPC pagination is sequential per function. Initialize based on overall page for simplicity here.
  const functionPageTracker: { [functionName: string]: number } = {};
  programConfig.functions.forEach(func => {
    functionPageTracker[func.name] = currentPage; // Initialize each function's page tracker
  });

  while (continueProgramIndexing) {
    let anyNewTransactionsFoundInCycle = false;
    const transactionsCollectedInThisCycle: AleoTransaction[] = [];

    for (const funcConfig of programConfig.functions) {
      let hasMoreTransactionsForFunction = true;
      let pageToProcessForFunction = functionPageTracker[funcConfig.name]; // Get current page for this specific function

      let pagesFetchedInThisFunctionCycle = 0;

      while (hasMoreTransactionsForFunction && pagesFetchedInThisFunctionCycle < MAX_PAGES_PER_FUNCTION_CYCLE) {
        let transactionsBatch: AleoTransaction[] = [];
        try {
          const rpcPayload = {
            programId: programConfig.programId,
            functionName: funcConfig.name, // Pass the specific function name for THIS function
            page: pageToProcessForFunction,
            maxTransactions: BATCH_SIZE,
          };
          logger.info({
            service: 'processor',
            msg: `Fetching transactions for ${programConfig.programId}:${funcConfig.name} on page ${pageToProcessForFunction}`,
            rpcPayload,
          });

          const response = await callRpc<AleoTransaction[]>(
            rpcUrl,
            "aleoTransactionsForProgram",
            rpcPayload
          );

          // Filter for finalized transactions and ensure they match the program and function
          transactionsBatch = (response || []).filter(tx =>
            (tx.status === "finalized" || (tx.status === "accepted" && tx.type === "execute"))&&
            tx.transaction?.execution?.transitions?.[0]?.program === programConfig.programId &&
            tx.transaction?.execution?.transitions?.[0]?.function === funcConfig.name
          );

        } catch (e: any) {
          if (e.message.includes('RPC permanent error')) {
            logger.error({
              service: 'processor',
              msg: `Permanent RPC error fetching transactions for ${programConfig.programId}:${funcConfig.name} on page ${pageToProcessForFunction}: ${e.message}`,
              error: e.message,
            });
            hasMoreTransactionsForFunction = false; // Stop fetching for this function
            continueProgramIndexing = false; // Potentially stop overall indexing for this program on critical error
            break; // Exit inner page loop for this function
          }
          logger.warn({
            service: 'processor',
            msg: `Transient error fetching transactions for ${programConfig.programId}:${funcConfig.name} on page ${pageToProcessForFunction}: ${e.message}`,
            error: e.message,
          });
          hasMoreTransactionsForFunction = false; // Stop current function's fetching for this cycle, retry in next cycle
          break; // Exit inner page loop for this function
        }

        if (transactionsBatch.length === 0) {
          logger.info({
            service: 'processor',
            msg: `No new finalized transactions for ${programConfig.programId}:${funcConfig.name} on page ${pageToProcessForFunction}.`,
          });
          hasMoreTransactionsForFunction = false; // No more transactions for this function
          break; // Exit inner page loop for this function
        } else {
          logger.info({
            service: 'processor',
            msg: `Fetched ${transactionsBatch.length} transactions for ${programConfig.programId}:${funcConfig.name} on page ${pageToProcessForFunction}.`,
          });
        }

        for (const tx of transactionsBatch) {
            // Only add if we haven't processed this transaction ID in this batch cycle yet
            if (!processedTransactionsSet.has(tx.transaction.id)) {
                transactionsCollectedInThisCycle.push(tx);
                processedTransactionsSet.add(tx.transaction.id);
                anyNewTransactionsFoundInCycle = true; // Mark that new transactions were found
            }
        }
        pageToProcessForFunction++; // Increment page for next fetch for THIS function
        pagesFetchedInThisFunctionCycle++; // Increment counter for this function's cycle
      }
      functionPageTracker[funcConfig.name] = pageToProcessForFunction; // Update tracker for next cycle for this function
    } // End of for (funcConfig of programConfig.functions)

    // If no new transactions were found across ALL functions in this entire cycle, stop
    if (!anyNewTransactionsFoundInCycle) {
      continueProgramIndexing = false;
      break; // Exit the main program indexing loop
    }

    // Sort all collected transactions by timestamp
    // This ensures sequential processing, which is crucial for state-based indexing.
    transactionsCollectedInThisCycle.sort((a, b) => {
      const blockA = parseInt(a.finalizedAt || '0');
      const blockB = parseInt(b.finalizedAt || '0');
      return blockA - blockB;
    });

    // Prepare data for batch inserts
    const baseTransactionsToInsert: any[] = [];
    const functionSpecificInserts: { [tableName: string]: any[] } = {};

    for (const tx of transactionsCollectedInThisCycle) {
        const functionName = tx.transaction?.execution?.transitions?.[0]?.function;
        const funcConfig = programConfig.functions.find(f => f.name === functionName);

        if (funcConfig) {
            // Call parseTransactionAndCollectMappingUpdates to get structured data
            const { baseTxData, funcSpecificData, mappingUpdateCandidates } = parseTransactionAndCollectMappingUpdates(tx, funcConfig, programConfig);
            baseTransactionsToInsert.push(baseTxData);

            if (!functionSpecificInserts[funcConfig.tableName]) {
                functionSpecificInserts[funcConfig.tableName] = [];
            }
            functionSpecificInserts[funcConfig.tableName].push({
                transactionId: tx.transaction.id, // Link to the base transaction
                ...funcSpecificData,
            });

            // Collect mapping update candidates from this transaction
            allMappingUpdateCandidates.push(...mappingUpdateCandidates);
        } else {
          logger.warn({
            service: 'processor',
            msg: `Transaction contains unconfigured function '${functionName}' for program '${programConfig.programId}'. Skipping.`,
            transactionId: tx.transaction.id,
          });
        }
    }
    logger.info({
      service: 'processor',
      msg: `Collected ${transactionsCollectedInThisCycle.length} transactions for program '${programConfig.programId}' in this cycle.`,
    });
    // Perform batch inserts for base transactions
    if (baseTransactionsToInsert.length > 0) {
      await db.insert(schema.transactions)
        .values(baseTransactionsToInsert)
        .onConflictDoNothing({ target: schema.transactions.id }); // Prevents inserting duplicates
      logger.info({
        service: 'processor',
        msg: `Inserted ${baseTransactionsToInsert.length} base transactions for ${programConfig.programId}.`,
      });
    }

    // Perform batch inserts for function-specific tables
    for (const tableName in functionSpecificInserts) {
      const records = functionSpecificInserts[tableName];
      if (records.length > 0) {
        const targetTable = schema[tableName]; // Access the table dynamically from the schema object
        if (targetTable) {
          await db.insert(targetTable)
            .values(records)
            .onConflictDoNothing(); // Prevents inserting duplicates based on primary key (serial id for events)
          logger.info({
            service: 'processor',
            msg: `Inserted ${records.length} records into '${tableName}' for ${programConfig.programId}.`,
          });
        } else {
          logger.error({
            service: 'processor',
            msg: `Drizzle table '${tableName}' not found in the loaded schema. Skipping inserts for this table.`,
          });
        }
      }
    }
    // Update the overall page tracker for the program if any new transactions were found in this cycle
    currentOverallPage++; // Assuming currentOverallPage increments per cycle of fetching across functions
  } // End of while (continueProgramIndexing) loop

  // Return the next overall page and all collected mapping update candidates
  return { nextPage: currentOverallPage, mappingUpdateCandidates: allMappingUpdateCandidates };
}

/**
 * Handles the indexing of mappings defined in a program configuration.
 * Fetches mapping values from RPC and updates the corresponding tables,
 * primarily driven by candidates generated from function processing.
 * @param mappingUpdateCandidates A list of mapping update requests generated from function processing.
 * @param programConfigs All program configurations to find mapping definitions.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 */
export async function handleProgramMappings(
  mappingUpdateCandidates: MappingUpdateCandidate[],
  programConfigs: ProgramConfig[], // Needs all program configs to find mapping definitions
  rpcUrl: string,
  db: DbInstance,
  schema: GeneratedSchema
) {
  if (mappingUpdateCandidates.length === 0) {
    logger.info({ service: 'processor', msg: 'No mapping update candidates to process.' });
    return;
  }

  logger.info({
    service: 'processor',
    msg: `Processing ${mappingUpdateCandidates.length} mapping update candidates.`,
  });

  // Use a Set to store unique key-mapping pairs to avoid redundant RPC calls and DB updates
  // Format: `${programId}:${mappingName}:${key}`
  const uniqueUpdatesToProcess = new Set<string>();
  mappingUpdateCandidates.forEach(candidate => {
    uniqueUpdatesToProcess.add(`${candidate.programId}:${candidate.mappingName}:${candidate.key}`);
  });

  for (const uniqueKey of uniqueUpdatesToProcess) {
    const [programId, mappingName, keyString] = uniqueKey.split(':');

    // Find the relevant mapping configuration
    const programConfig = programConfigs.find(p => p.programId === programId);
    const mappingConfig = programConfig?.mappings?.find(m => m.name === mappingName);

    if (!mappingConfig) {
      logger.warn({
        service: 'processor',
        msg: `Mapping configuration not found for '${mappingName}' in program '${programId}'. Skipping update.`,
      });
      continue;
    }

    const targetTable = schema[mappingConfig.tableName];
    if (!targetTable) {
      logger.error({
        service: 'processor',
        msg: `Generated table '${mappingConfig.tableName}' not found in schema for mapping '${mappingName}'. Skipping update.`,
      });
      continue;
    }

    try {
        // Find the original candidate to get the block height and potentially a pre-parsed value
        const originalCandidate = mappingUpdateCandidates.find(
            c => c.programId === programId && c.mappingName === mappingName && c.key === keyString
        );
        const blockHeight = originalCandidate?.blockHeight || 0; // Use candidate's block height or fallback

        let rpcValue: string | undefined = originalCandidate?.value; // Use pre-extracted value if available

        if (rpcValue === undefined) { // If value wasn't directly provided by the function processing/finalize, fetch it via RPC
            rpcValue = await callRpc<string>(
                rpcUrl,
                "getMappingValue",
                {
                    programId: programId,
                    mappingName: mappingConfig.name,
                    key: keyString,
                }
            );
        }

        if (rpcValue !== undefined && rpcValue !== null) {
            const key = parseAleoValue(keyString, mappingConfig.key.aleoType);
            const value = parseAleoValue(rpcValue, mappingConfig.value);

            await db.insert(targetTable)
                .values({
                    key: key,
                    value: value,
                    lastUpdatedBlock: blockHeight, // Use candidate's block height
                })
                .onConflictDoUpdate({
                    target: targetTable.key,
                    set: {
                        value: value,
                        lastUpdatedBlock: blockHeight,
                    },
                });
            logger.debug({
                service: 'processor',
                msg: `Updated mapping '${mappingConfig.name}' with key '${keyString}' in block ${blockHeight}.`,
            });
        } else {
            logger.debug({
                service: 'processor',
                msg: `Mapping '${mappingConfig.name}' for key '${keyString}' returned no value from RPC. It might have been deleted or not exist.`,
            });
        }
    } catch (error: any) {
        logger.warn({
            service: 'processor',
            msg: `Failed to fetch or update mapping '${mappingConfig.name}' for key '${keyString}': ${error.message}`,
            error: error.message,
        });
    }
  }
}

/**
 * Helper to parse Aleo values (from RPC strings) into appropriate JS types.
 * @param aleoValueStr The string value from Aleo RPC (e.g., "123u128", "aleo123...", "{a: 1u8}").
 * @param targetType The expected Aleo type.
 * @returns The parsed JavaScript value.
 */
function parseAleoValue(aleoValueStr: string, targetType: AleoValueType): any {
  if (targetType.kind === 'primitive') {
    switch (targetType.type) {
      case 'address':
      case 'field':
      case 'boolean':
        return aleoValueStr;
      case 'u8':
      case 'u16':
      case 'u32':
        return parseInt(aleoValueStr.replace(/u(8|16|32)/, ''));
      case 'u64':
      case 'u128':
        return BigInt(aleoValueStr.replace(/u(64|128)/, ''));
      default:
        return aleoValueStr;
    }
  } else if (targetType.kind === 'record' || targetType.kind === 'struct' || targetType.kind === 'array') {
    try {
      return JSON.parse(aleoValueStr);
    } catch (e) {
      logger.warn({
        service: 'processor',
        msg: `Failed to parse complex Aleo value string as JSON for type ${targetType.kind}: ${aleoValueStr}`,
        error: e,
      });
      return aleoValueStr;
    }
  }
  return aleoValueStr;
}