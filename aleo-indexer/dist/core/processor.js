// aleo-indexer/src/core/processor.ts
import { logger } from '../utils/logger.js';
import { getNestedValue } from '../utils/types.js';
import { callRpc } from './rpc.js';
const BATCH_SIZE = 50; // Number of transactions to fetch per RPC call
/**
 * Parses and transforms an Aleo transaction based on the function configuration.
 * @param tx The raw Aleo transaction object.
 * @param funcConfig The configuration for the function being processed.
 * @param programConfig The configuration for the entire Aleo program. // ADDED THIS PARAMETER
 * @returns An object containing data for the main transactions table, function-specific table,
 * and any mapping update candidates generated by this transaction.
 */
function parseTransactionAndCollectMappingUpdates(tx, funcConfig, programConfig) {
    // Extract common fields for the main transactions table
    const baseTxData = {
        id: tx.transaction.id,
        programId: tx.transaction.execution?.transitions?.[0]?.program || 'unknown',
        functionName: tx.transaction.execution?.transitions?.[0]?.function || 'unknown',
        blockHeight: tx.finalizedAt ? parseInt(tx.finalizedAt.split('.')[0]) : 0,
        timestamp: tx.finalizedAt ? new Date(parseInt(tx.finalizedAt) * 1000) : new Date(),
        raw: tx, // Store the entire raw transaction for debugging/auditing
    };
    // Extract specific fields for the function's dedicated table
    const funcSpecificData = {};
    for (const input of funcConfig.inputs) {
        let inputValue;
        const transitionInputs = tx.transaction?.execution?.transitions?.[0]?.inputs;
        if (input.rpcPath) {
            inputValue = getNestedValue(tx, input.rpcPath);
        }
        else if (transitionInputs) {
            const foundInput = transitionInputs.find(i => i.id === input.name);
            inputValue = foundInput?.value;
            if (input.aleoType.kind === 'record' || input.aleoType.kind === 'struct' || input.aleoType.kind === 'array') {
                try {
                    inputValue = JSON.parse(inputValue);
                }
                catch (e) {
                    logger.warn({
                        service: 'processor',
                        msg: `Failed to parse complex input for ${input.name}: ${inputValue}`,
                        error: e,
                    });
                }
            }
            else if (input.aleoType.kind === 'primitive' && (input.aleoType.type === 'u64' || input.aleoType.type === 'u128')) {
                inputValue = BigInt(inputValue);
            }
        }
        funcSpecificData[input.name] = inputValue;
    }
    for (const dbColumnName in funcConfig.extract) {
        const rpcPath = funcConfig.extract[dbColumnName];
        funcSpecificData[dbColumnName] = getNestedValue(tx, rpcPath);
    }
    // Collect mapping update candidates
    const mappingUpdateCandidates = [];
    const blockHeight = baseTxData.blockHeight;
    if (funcConfig.triggersMappingUpdates) {
        for (const trigger of funcConfig.triggersMappingUpdates) {
            const key = getNestedValue(funcSpecificData, trigger.keySource);
            if (key !== undefined) { // Ensure key was successfully extracted
                const candidate = {
                    programId: programConfig.programId, // Use programConfig from parameter
                    mappingName: trigger.mappingName,
                    key: String(key), // Ensure key is string for RPC calls
                    blockHeight: blockHeight,
                };
                if (trigger.valueSource) {
                    const value = getNestedValue(funcSpecificData, trigger.valueSource);
                    if (value !== undefined) {
                        candidate.value = String(value); // Ensure value is string
                    }
                }
                mappingUpdateCandidates.push(candidate);
            }
            else {
                logger.warn({
                    service: 'processor',
                    msg: `Mapping update trigger for '${trigger.mappingName}' in function '${funcConfig.name}' could not extract key from source '${trigger.keySource}'.`,
                    transactionId: tx.transaction.id,
                });
            }
        }
    }
    // Also collect updates from the transaction's `finalize` section, as they directly state mapping changes
    if (tx.finalize && tx.finalizedAt) {
        for (const finalizeEntry of tx.finalize) {
            // Find which configured mapping this finalize entry corresponds to
            const matchingMappingConfig = programConfig.mappings?.find(// programConfig is now in scope
            // programConfig is now in scope
            m => m.name === finalizeEntry.mapping_id.split('/').pop() // Extract mapping name from mapping_id
            );
            if (matchingMappingConfig) {
                const key = getNestedValue(finalizeEntry, matchingMappingConfig.key.rpcPath || 'key_id');
                const value = getNestedValue(finalizeEntry, matchingMappingConfig.rpcValuePath || 'value_id');
                if (key !== undefined && value !== undefined) {
                    mappingUpdateCandidates.push({
                        programId: programConfig.programId, // Use programConfig from parameter
                        mappingName: matchingMappingConfig.name,
                        key: String(key),
                        value: String(value),
                        blockHeight: blockHeight,
                    });
                }
                else {
                    logger.warn({
                        service: 'processor',
                        msg: `Finalize entry for mapping '${matchingMappingConfig.name}' could not extract key or value.`,
                        transactionId: tx.transaction.id,
                    });
                }
            }
        }
    }
    return {
        baseTxData,
        funcSpecificData,
        mappingUpdateCandidates,
    };
}
/**
 * Handles the indexing of functions defined in a program configuration.
 * Fetches transactions, parses them, and inserts into the appropriate tables.
 * @param programConfig The configuration for the current Aleo program.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 * @param currentPage The page number to start fetching transactions from.
 * @returns An object containing the next page number and a list of generated mapping update candidates.
 */
export async function handleProgramFunctions(programConfig, rpcUrl, db, schema, currentPage) {
    if (!programConfig.functions || programConfig.functions.length === 0) {
        return { nextPage: currentPage, mappingUpdateCandidates: [] }; // No functions to process
    }
    logger.info({
        service: 'processor',
        msg: `Processing functions for program '${programConfig.programId}' starting from page ${currentPage}`,
    });
    let hasMoreTransactions = true;
    let pageToProcess = currentPage;
    const allMappingUpdateCandidates = [];
    while (hasMoreTransactions) {
        let transactionsBatch = [];
        try {
            const response = await callRpc(rpcUrl, "aleoTransactionsForProgram", {
                programName: programConfig.programId,
                page: pageToProcess,
                maxTransactions: BATCH_SIZE,
            });
            transactionsBatch = (response || []).filter(tx => tx.status === "finalized" && tx.transaction?.execution?.transitions?.[0]?.program === programConfig.programId);
        }
        catch (e) {
            if (e.message.includes('RPC permanent error')) {
                logger.error({
                    service: 'processor',
                    msg: `Permanent RPC error fetching transactions for ${programConfig.programId} on page ${pageToProcess}: ${e.message}`,
                });
                hasMoreTransactions = false;
                break;
            }
            logger.warn({
                service: 'processor',
                msg: `Transient error fetching transactions for ${programConfig.programId} on page ${pageToProcess}: ${e.message}`,
                error: e.message,
            });
            // In case of transient error, return current candidates and page to retry
            return { nextPage: pageToProcess, mappingUpdateCandidates: allMappingUpdateCandidates };
        }
        if (transactionsBatch.length === 0) {
            logger.info({
                service: 'processor',
                msg: `No new finalized transactions for ${programConfig.programId} on page ${pageToProcess}.`,
            });
            hasMoreTransactions = false;
            break;
        }
        const baseTransactionsToInsert = [];
        const functionSpecificInserts = {};
        for (const tx of transactionsBatch) {
            const functionName = tx.transaction?.execution?.transitions?.[0]?.function;
            const funcConfig = programConfig.functions.find(f => f.name === functionName);
            if (funcConfig) {
                // PASSED programConfig HERE
                const { baseTxData, funcSpecificData, mappingUpdateCandidates } = parseTransactionAndCollectMappingUpdates(tx, funcConfig, programConfig);
                baseTransactionsToInsert.push(baseTxData);
                if (!functionSpecificInserts[funcConfig.tableName]) {
                    functionSpecificInserts[funcConfig.tableName] = [];
                }
                functionSpecificInserts[funcConfig.tableName].push({
                    transactionId: tx.transaction.id,
                    ...funcSpecificData,
                });
                allMappingUpdateCandidates.push(...mappingUpdateCandidates); // Collect candidates
            }
            else {
                logger.warn({
                    service: 'processor',
                    msg: `Encountered unconfigured function '${functionName}' in program '${programConfig.programId}'. Skipping.`,
                    transactionId: tx.transaction.id,
                });
            }
        }
        if (baseTransactionsToInsert.length > 0) {
            await db.insert(schema.transactions)
                .values(baseTransactionsToInsert)
                .onConflictDoNothing({ target: schema.transactions.id });
            logger.info({
                service: 'processor',
                msg: `Inserted ${baseTransactionsToInsert.length} base transactions for ${programConfig.programId}.`,
            });
        }
        for (const tableName in functionSpecificInserts) {
            const records = functionSpecificInserts[tableName];
            if (records.length > 0) {
                const targetTable = schema[tableName];
                if (targetTable) {
                    await db.insert(targetTable)
                        .values(records)
                        .onConflictDoNothing();
                    logger.info({
                        service: 'processor',
                        msg: `Inserted ${records.length} records into '${tableName}' for ${programConfig.programId}.`,
                    });
                }
                else {
                    logger.error({
                        service: 'processor',
                        msg: `Generated table '${tableName}' not found in schema. Skipping inserts.`,
                    });
                }
            }
        }
        pageToProcess++;
    }
    return { nextPage: pageToProcess, mappingUpdateCandidates: allMappingUpdateCandidates };
}
/**
 * Handles the indexing of mappings defined in a program configuration.
 * Fetches mapping values from RPC and updates the corresponding tables,
 * primarily driven by candidates generated from function processing.
 * @param mappingUpdateCandidates A list of mapping update requests generated from function processing.
 * @param programConfigs All program configurations to find mapping definitions.
 * @param rpcUrl The RPC URL to use for API calls.
 * @param db The Drizzle DB instance.
 * @param schema The dynamically loaded Drizzle schema.
 */
export async function handleProgramMappings(mappingUpdateCandidates, programConfigs, // Needs all program configs to find mapping definitions
rpcUrl, db, schema) {
    if (mappingUpdateCandidates.length === 0) {
        logger.info({ service: 'processor', msg: 'No mapping update candidates to process.' });
        return;
    }
    logger.info({
        service: 'processor',
        msg: `Processing ${mappingUpdateCandidates.length} mapping update candidates.`,
    });
    // Use a Set to store unique key-mapping pairs to avoid redundant RPC calls and DB updates
    // Format: `${programId}:${mappingName}:${key}`
    const uniqueUpdatesToProcess = new Set();
    mappingUpdateCandidates.forEach(candidate => {
        uniqueUpdatesToProcess.add(`${candidate.programId}:${candidate.mappingName}:${candidate.key}`);
    });
    for (const uniqueKey of uniqueUpdatesToProcess) {
        const [programId, mappingName, keyString] = uniqueKey.split(':');
        // Find the relevant mapping configuration
        const programConfig = programConfigs.find(p => p.programId === programId);
        const mappingConfig = programConfig?.mappings?.find(m => m.name === mappingName);
        if (!mappingConfig) {
            logger.warn({
                service: 'processor',
                msg: `Mapping configuration not found for '${mappingName}' in program '${programId}'. Skipping update.`,
            });
            continue;
        }
        const targetTable = schema[mappingConfig.tableName];
        if (!targetTable) {
            logger.error({
                service: 'processor',
                msg: `Generated table '${mappingConfig.tableName}' not found in schema for mapping '${mappingName}'. Skipping update.`,
            });
            continue;
        }
        try {
            // Find the original candidate to get the block height and potentially a pre-parsed value
            const originalCandidate = mappingUpdateCandidates.find(c => c.programId === programId && c.mappingName === mappingName && c.key === keyString);
            const blockHeight = originalCandidate?.blockHeight || 0; // Use candidate's block height or fallback
            let rpcValue = originalCandidate?.value; // Use pre-extracted value if available
            if (rpcValue === undefined) { // If value wasn't directly provided by the function processing/finalize, fetch it via RPC
                rpcValue = await callRpc(rpcUrl, "getMappingValue", {
                    programId: programId,
                    mappingName: mappingConfig.name,
                    key: keyString,
                });
            }
            if (rpcValue !== undefined && rpcValue !== null) {
                const key = parseAleoValue(keyString, mappingConfig.key.aleoType);
                const value = parseAleoValue(rpcValue, mappingConfig.value);
                await db.insert(targetTable)
                    .values({
                    key: key,
                    value: value,
                    lastUpdatedBlock: blockHeight, // Use candidate's block height
                })
                    .onConflictDoUpdate({
                    target: targetTable.key,
                    set: {
                        value: value,
                        lastUpdatedBlock: blockHeight,
                    },
                });
                logger.debug({
                    service: 'processor',
                    msg: `Updated mapping '${mappingConfig.name}' with key '${keyString}' in block ${blockHeight}.`,
                });
            }
            else {
                logger.debug({
                    service: 'processor',
                    msg: `Mapping '${mappingConfig.name}' for key '${keyString}' returned no value from RPC. It might have been deleted or not exist.`,
                });
            }
        }
        catch (error) {
            logger.warn({
                service: 'processor',
                msg: `Failed to fetch or update mapping '${mappingConfig.name}' for key '${keyString}': ${error.message}`,
                error: error.message,
            });
        }
    }
}
/**
 * Helper to parse Aleo values (from RPC strings) into appropriate JS types.
 * @param aleoValueStr The string value from Aleo RPC (e.g., "123u128", "aleo123...", "{a: 1u8}").
 * @param targetType The expected Aleo type.
 * @returns The parsed JavaScript value.
 */
function parseAleoValue(aleoValueStr, targetType) {
    if (targetType.kind === 'primitive') {
        switch (targetType.type) {
            case 'address':
            case 'field':
            case 'boolean':
                return aleoValueStr;
            case 'u8':
            case 'u16':
            case 'u32':
                return parseInt(aleoValueStr.replace(/u(8|16|32)/, ''));
            case 'u64':
            case 'u128':
                return BigInt(aleoValueStr.replace(/u(64|128)/, ''));
            default:
                return aleoValueStr;
        }
    }
    else if (targetType.kind === 'record' || targetType.kind === 'struct' || targetType.kind === 'array') {
        try {
            return JSON.parse(aleoValueStr);
        }
        catch (e) {
            logger.warn({
                service: 'processor',
                msg: `Failed to parse complex Aleo value string as JSON for type ${targetType.kind}: ${aleoValueStr}`,
                error: e,
            });
            return aleoValueStr;
        }
    }
    return aleoValueStr;
}
//# sourceMappingURL=processor.js.map